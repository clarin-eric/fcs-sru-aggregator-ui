{"version":3,"file":"prism.js","sources":["../../../src/vendor/prismjs/shared/dom-util.ts","../../../src/vendor/prismjs/shared/symbols.ts","../../../src/vendor/prismjs/shared/util.ts","../../../src/vendor/prismjs/core/hook-state.ts","../../../src/vendor/prismjs/core/hooks.ts","../../../src/vendor/prismjs/core/linked-list.ts","../../../src/vendor/prismjs/shared/language-util.ts","../../../src/vendor/prismjs/core/registry.ts","../../../src/vendor/prismjs/core/token.ts","../../../src/vendor/prismjs/core/prism.ts","../../../src/vendor/prismjs/global.ts","../../../src/vendor/prismjs/languages/prism-plain.ts","../../../src/vendor/prismjs/languages/prism-regex.ts","../../../src/vendor/prismjs/languages/prism-cql.ts","../../../src/vendor/prismjs/languages/prism-fcs-cql.ts","../../../src/vendor/prismjs/languages/prism-fcs-fcsql.ts","../../../src/vendor/prismjs/languages/prism-fcs-lexcql.ts","../../../src/vendor/prismjs/plugins/match-braces/prism-match-braces.ts","../../../src/vendor/prismjs/index.ts"],"sourcesContent":["const lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\n/**\n * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n *\n * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n */\nexport function getLanguage (element: Element): string {\n\tlet e: Element | null = element;\n\tfor (; e; e = e.parentElement) {\n\t\tconst m = lang.exec(e.className);\n\t\tif (m) {\n\t\t\treturn m[1].toLowerCase();\n\t\t}\n\t}\n\treturn 'none';\n}\n\n/**\n * Sets the Prism `language-xxxx` class of the given element.\n */\nexport function setLanguage (element: Element, language: string): void {\n\t// remove all `language-xxxx` classes\n\t// (this might leave behind a leading space)\n\t// eslint-disable-next-line regexp/no-unused-capturing-group\n\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t// add the new `language-xxxx` class\n\t// (using `classList` will automatically clean up spaces for us)\n\telement.classList.add('language-' + language);\n}\n\n/**\n * Returns whether a given class is active for `element`.\n *\n * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n * given class is just the given class with a `no-` prefix.\n *\n * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n * ancestors have the given class or the negated version of it, then the default activation will be returned.\n *\n * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n * version of it, the class is considered active.\n *\n * @param element\n * @param className\n * @param defaultActivation Defaults to `false`.\n * @returns\n */\nexport function isActive (\n\telement: Element | null,\n\tclassName: string,\n\tdefaultActivation = false\n): boolean {\n\treturn (\n\t\telement?.closest(`.${className}, .no-${className}`)?.classList?.contains(className) ??\n\t\tdefaultActivation\n\t);\n}\n\n/**\n * If the parent element of the given element is a `<pre>` element, then if\n * will be returned. Otherwise, `undefined` will be returned.\n */\nexport function getParentPre (element: Element): HTMLPreElement | undefined {\n\tconst pre = element.parentElement;\n\tif (pre && /pre/i.test(pre.nodeName)) {\n\t\treturn pre as HTMLPreElement;\n\t}\n}\n","/**\n * The symbol grammars use to indicate a rest grammar.\n */\nexport const rest = Symbol.for('Prism rest');\n\n/**\n * The symbol grammars use for a custom tokenizer.\n */\nexport const tokenize = Symbol.for('Prism tokenize');\n","import type { KebabToCamelCase } from '../types';\n\n/**\n * Returns a function that caches the result of the given supplier.\n */\nexport function lazy<T> (supplier: () => T): () => T {\n\tlet value: T;\n\tlet hasValue = false;\n\treturn () => {\n\t\tif (hasValue) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvalue = supplier();\n\t\thasValue = true;\n\t\treturn value;\n\t};\n}\n\nexport function htmlEncode (text: string): string {\n\treturn text\n\t\t.replace(/&/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/\\u00a0/g, ' ');\n}\n\n/**\n * A function that does nothing.\n */\nexport const noop = (() => {\n\t/* noop */\n}) as () => void & undefined;\n\nexport function isNonNull<T> (value: T): value is T & {} {\n\treturn value != null;\n}\n\n/**\n * Escapes all special regex characters in the given string.\n */\nexport function regexEscape (string: string): string {\n\treturn string.replace(/([\\\\[\\](){}+*?|^$.])/g, '\\\\$1');\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isReadonlyArray: (arg: unknown) => arg is readonly any[] = Array.isArray;\n\n/**\n * Converts the given value to an array.\n *\n * If the given value is already an error, it will be returned as is.\n */\nexport function toArray<T extends {}> (value: T | readonly T[] | undefined | null): readonly T[] {\n\tif (isReadonlyArray(value)) {\n\t\treturn value;\n\t}\n\telse if (value == null) {\n\t\treturn [];\n\t}\n\telse {\n\t\treturn [value];\n\t}\n}\n\n/**\n * Invokes the given callback for all elements of the given value.\n *\n * If the given value is an array, the callback will be invokes for all elements. If the given value is `null` or\n * `undefined`, the callback will not be invoked. In all other cases, the callback will be invoked with the given\n * value as parameter.\n */\nexport function forEach<T extends {}> (\n\tvalue: null | undefined | T | readonly T[],\n\tcallbackFn: (value: T, index: number) => void\n): void {\n\tif (Array.isArray(value)) {\n\t\tvalue.forEach(callbackFn);\n\t}\n\telse if (value != null) {\n\t\tcallbackFn(value as T, 0);\n\t}\n}\n\nexport function capitalize<T extends string> (string: T): Capitalize<T> {\n\t// This is the internal implementation of `Capitalize<T>` by TS.\n\t// https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#capitalizestringtype\n\treturn (string.charAt(0).toUpperCase() + string.slice(1)) as Capitalize<T>;\n}\n\n/**\n * Converts the given kebab case identifier to a camel case identifier.\n */\nexport function kebabToCamelCase<T extends string> (kebab: T): KebabToCamelCase<T> {\n\tconst [first, ...others] = kebab.split(/-/);\n\treturn (first + others.map(capitalize).join('')) as KebabToCamelCase<T>;\n}\n","export type StateKey<T> = (string | symbol) & { __keyType?: T };\n\n/**\n * A simple typed map from some key to its data.\n */\nexport class HookState {\n\tprivate _data = new Map<string | symbol, {}>();\n\n\thas (key: StateKey<{}>): boolean {\n\t\treturn this._data.has(key);\n\t}\n\n\tget<T extends {}> (key: StateKey<T>, defaultValue: T) {\n\t\tlet current = this._data.get(key);\n\t\tif (current === undefined) {\n\t\t\tcurrent = defaultValue;\n\t\t\tthis._data.set(key, current);\n\t\t}\n\t\treturn current as T;\n\t}\n\n\tset<T extends {}> (key: StateKey<T>, value: T): void {\n\t\tthis._data.set(key, value);\n\t}\n}\n","import type { Grammar, TokenName } from '../types';\nimport type { HookState } from './hook-state';\nimport type { TokenStream } from './token';\n\nexport class Hooks {\n\t// eslint-disable-next-line func-call-spacing\n\tprivate _all = new Map<string, ((env: unknown) => void)[]>();\n\n\t/**\n\t * Adds the given callback to the list of callbacks for the given hook and returns a function that\n\t * removes the hook again when called.\n\t *\n\t * The callback will be invoked when the hook it is registered for is run.\n\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t *\n\t * One callback function can be registered to multiple hooks.\n\t *\n\t * A callback function must not be registered for the same hook multiple times. Doing so will cause\n\t * undefined behavior. However, registering a callback again after removing it is fine.\n\t *\n\t * @param name The name of the hook.\n\t * @param callback The callback function which is given environment variables.\n\t */\n\tadd<Name extends string> (name: Name, callback: HookCallback<Name>): () => void {\n\t\tlet hooks = this._all.get(name);\n\t\tif (hooks === undefined) {\n\t\t\thooks = [];\n\t\t\tthis._all.set(name, hooks);\n\t\t}\n\t\tconst list = hooks;\n\n\t\tlist.push(callback as never);\n\n\t\treturn () => {\n\t\t\tconst index = list.indexOf(callback as never);\n\t\t\tif (index !== -1) {\n\t\t\t\tlist.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t *\n\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t *\n\t * @param name The name of the hook.\n\t * @param env The environment variables of the hook passed to all callbacks registered.\n\t */\n\trun<Name extends string> (name: Name, env: HookEnv<Name>): void {\n\t\tconst callbacks = this._all.get(name);\n\n\t\tif (!callbacks || !callbacks.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(env);\n\t\t}\n\t}\n}\n\n/**\n * An interface containing all hooks Prism runs.\n */\nexport interface HookEnvMap {\n\t// Prism.highlightAll\n\t'before-highlightall': BeforeHighlightAllEnv;\n\t'before-all-elements-highlight': BeforeAllElementsHighlightEnv;\n\n\t// Prism.highlightElement\n\t'before-sanity-check': BeforeSanityCheckEnv;\n\t'before-highlight': BeforeHighlightEnv;\n\n\t'before-insert': BeforeInsertEnv;\n\t'after-highlight': AfterHighlightEnv;\n\t'complete': CompleteEnv;\n\n\t// Prism.highlight\n\t'before-tokenize': BeforeTokenizeEnv;\n\t'after-tokenize': AfterTokenizeEnv;\n\n\t// stringify\n\t'wrap': WrapEnv;\n}\n\nexport type HookEnv<HookName extends string> = HookName extends keyof HookEnvMap\n\t? HookEnvMap[HookName]\n\t: unknown;\n\nexport type HookCallback<HookName extends string> = (env: HookEnv<HookName>) => void;\n\ninterface StatefulEnv {\n\treadonly state: HookState;\n}\n\nexport interface BeforeHighlightAllEnv extends StatefulEnv {\n\troot: ParentNode;\n\tselector: string;\n\tcallback?: (element: Element) => void;\n}\nexport interface BeforeAllElementsHighlightEnv extends StatefulEnv {\n\troot: ParentNode;\n\tselector: string;\n\tcallback?: (element: Element) => void;\n\telements: Element[];\n}\n\nexport interface BeforeSanityCheckEnv extends StatefulEnv {\n\telement: Element;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n\tcode: string;\n}\nexport interface BeforeHighlightEnv extends StatefulEnv {\n\telement: Element;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n\tcode: string;\n}\nexport interface CompleteEnv extends StatefulEnv {\n\telement: Element;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n\tcode: string;\n}\nexport interface BeforeInsertEnv extends StatefulEnv {\n\telement: Element;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n\tcode: string;\n\thighlightedCode: string;\n}\nexport interface AfterHighlightEnv extends StatefulEnv {\n\telement: Element;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n\tcode: string;\n\thighlightedCode: string;\n}\n\nexport interface BeforeTokenizeEnv {\n\tcode: string;\n\tlanguage: string;\n\tgrammar: Grammar | undefined;\n}\nexport interface AfterTokenizeEnv {\n\tcode: string;\n\tlanguage: string;\n\tgrammar: Grammar;\n\ttokens: TokenStream;\n}\n\nexport interface WrapEnv {\n\ttype: TokenName;\n\tcontent: string;\n\ttag: string;\n\tclasses: string[];\n\tattributes: Record<string, string>;\n\tlanguage: string;\n}\n","export interface LinkedListMiddleNode<T> {\n\tvalue: T;\n\tprev: LinkedListMiddleNode<T> | LinkedListHeadNode<T>;\n\tnext: LinkedListMiddleNode<T> | LinkedListTailNode<T>;\n}\nexport interface LinkedListHeadNode<T> {\n\tvalue: null;\n\tprev: null;\n\tnext: LinkedListMiddleNode<T> | LinkedListTailNode<T>;\n}\nexport interface LinkedListTailNode<T> {\n\tvalue: null;\n\tprev: LinkedListMiddleNode<T> | LinkedListHeadNode<T>;\n\tnext: null;\n}\n\nexport class LinkedList<T> {\n\treadonly head: LinkedListHeadNode<T>;\n\treadonly tail: LinkedListTailNode<T>;\n\tlength: number;\n\n\tconstructor () {\n\t\tconst head: LinkedListHeadNode<T> = { value: null, prev: null, next: null as never };\n\t\tconst tail: LinkedListTailNode<T> = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\tthis.head = head;\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param node\n\t * @param value\n\t * @returns The added node.\n\t */\n\taddAfter (\n\t\tnode: LinkedListHeadNode<T> | LinkedListMiddleNode<T>,\n\t\tvalue: T\n\t): LinkedListMiddleNode<T> {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tconst next = node.next;\n\n\t\tconst newNode = { value, prev: node, next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tthis.length++;\n\n\t\treturn newNode;\n\t}\n\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t */\n\tremoveRange (node: LinkedListHeadNode<T> | LinkedListMiddleNode<T>, count: number): void {\n\t\tlet next = node.next;\n\t\tlet i = 0;\n\t\tfor (; i < count && next.next !== null; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tthis.length -= i;\n\t}\n\n\ttoArray (): T[] {\n\t\tconst array: T[] = [];\n\t\tlet node = this.head.next;\n\t\twhile (node.next !== null) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n}\n","import { rest, tokenize } from './symbols';\nimport type { Grammar, GrammarToken, GrammarTokens, RegExpLike } from '../types';\n\n// TODO: Update documentation\n\n/**\n * Inserts tokens _before_ another token in the given grammar.\n *\n * ## Usage\n *\n * This helper method makes it easy to modify existing grammars. For example, the CSS language definition\n * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n * this:\n *\n * ```js\n * markup.style = {\n *     // token\n * };\n * ```\n *\n * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n * before existing tokens. For the CSS example above, you would use it like this:\n *\n * ```js\n * insertBefore(markup, 'cdata', {\n *     'style': {\n *         // token\n *     }\n * });\n * ```\n *\n * ## Special cases\n *\n * If the grammars of `grammar` and `insert` have tokens with the same name, the tokens in `grammar`'s grammar\n * will be ignored.\n *\n * This behavior can be used to insert tokens after `before`:\n *\n * ```js\n * insertBefore(markup, 'comment', {\n *     'comment': markup.comment,\n *     // tokens after 'comment'\n * });\n * ```\n *\n * @param grammar The grammar to be modified.\n * @param before The key to insert before.\n * @param insert An object containing the key-value pairs to be inserted.\n */\nexport function insertBefore (grammar: Grammar, before: string, insert: GrammarTokens) {\n\tif (!(before in grammar)) {\n\t\tthrow new Error(`\"${before}\" has to be a key of grammar.`);\n\t}\n\n\tconst grammarEntries = Object.entries(grammar);\n\n\t// delete all keys in `grammar`\n\tfor (const [key] of grammarEntries) {\n\t\tdelete grammar[key];\n\t}\n\n\t// insert keys again\n\tfor (const [key, value] of grammarEntries) {\n\t\tif (key === before) {\n\t\t\tfor (const insertKey of Object.keys(insert)) {\n\t\t\t\tgrammar[insertKey] = insert[insertKey];\n\t\t\t}\n\t\t}\n\n\t\t// Do not insert tokens which also occur in `insert`. See #1525\n\t\tif (!insert.hasOwnProperty(key)) {\n\t\t\tgrammar[key] = value;\n\t\t}\n\t}\n}\n\n/**\n * Creates a deep copy of the language with the given id and appends the given tokens.\n *\n * If a token in `reDef` also appears in the copied language, then the existing token in the copied language\n * will be overwritten at its original position.\n *\n * ## Best practices\n *\n * Since the position of overwriting tokens (token in `reDef` that overwrite tokens in the copied language)\n * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n *\n * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n *\n * @param grammar The grammar of the language to extend.\n * @param id The id of the language to extend.\n * @param reDef The new tokens to append.\n * @returns The new language created.\n * @example\n * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n *     // at its original position\n *     'comment': { ... },\n *     // CSS doesn't have a 'color' token, so this token will be appended\n *     'color': /\\b(?:red|green|blue)\\b/\n * });\n */\nexport function extend (grammar: Grammar, id: string, reDef: Grammar): Grammar {\n\tconst lang = cloneGrammar(grammar, id);\n\n\tfor (const key in reDef) {\n\t\tlang[key] = reDef[key];\n\t}\n\n\treturn lang;\n}\n\nfunction cloneGrammar (grammar: Grammar, id: string): Grammar {\n\tconst result: Grammar = {};\n\n\tconst visited = new Map<Grammar, Grammar>();\n\n\tfunction cloneToken (value: GrammarToken | RegExpLike) {\n\t\tif (!value.pattern) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tconst copy: GrammarToken = { pattern: value.pattern };\n\t\t\tif (value.lookbehind) {\n\t\t\t\tcopy.lookbehind = value.lookbehind;\n\t\t\t}\n\t\t\tif (value.greedy) {\n\t\t\t\tcopy.greedy = value.greedy;\n\t\t\t}\n\t\t\tif (value.alias) {\n\t\t\t\tcopy.alias = Array.isArray(value.alias) ? [...value.alias] : value.alias;\n\t\t\t}\n\t\t\tif (value.inside) {\n\t\t\t\tcopy.inside = cloneRef(value.inside);\n\t\t\t}\n\t\t\treturn copy;\n\t\t}\n\t}\n\tfunction cloneTokens (value: GrammarTokens[string]) {\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\telse if (Array.isArray(value)) {\n\t\t\treturn value.map(cloneToken);\n\t\t}\n\t\telse {\n\t\t\treturn cloneToken(value);\n\t\t}\n\t}\n\tfunction cloneRef (ref: NonNullable<Grammar[typeof rest]>) {\n\t\tif (ref === id) {\n\t\t\t// self ref\n\t\t\treturn result;\n\t\t}\n\t\telse if (typeof ref === 'string') {\n\t\t\treturn ref;\n\t\t}\n\t\telse {\n\t\t\treturn clone(ref);\n\t\t}\n\t}\n\tfunction clone (value: Grammar) {\n\t\tlet mapped = visited.get(value);\n\t\tif (mapped === undefined) {\n\t\t\tmapped = value === grammar ? result : {};\n\t\t\tvisited.set(value, mapped);\n\n\t\t\t// tokens\n\t\t\tfor (const [key, tokens] of Object.entries(value)) {\n\t\t\t\tmapped[key] = cloneTokens(tokens);\n\t\t\t}\n\n\t\t\t// rest\n\t\t\tconst r = value[rest];\n\t\t\tif (r != null) {\n\t\t\t\tmapped[rest] = cloneRef(r);\n\t\t\t}\n\n\t\t\t// tokenize\n\t\t\tconst t = value[tokenize];\n\t\t\tif (t) {\n\t\t\t\tmapped[tokenize] = t;\n\t\t\t}\n\t\t}\n\t\treturn mapped;\n\t}\n\n\treturn clone(grammar);\n}\n\nexport function withoutTokenize (grammar: Grammar): Grammar {\n\tif (!grammar[tokenize]) {\n\t\treturn grammar;\n\t}\n\n\tconst copy = { ...grammar };\n\tdelete copy[tokenize];\n\treturn copy;\n}\n","import { extend } from '../shared/language-util';\nimport { forEach, kebabToCamelCase } from '../shared/util';\nimport type { ComponentProto, Grammar } from '../types';\nimport type { Prism } from './prism';\n\ninterface Entry {\n\tproto: ComponentProto;\n\tevaluatedGrammar?: Grammar;\n\tevaluatedEffect?: () => void;\n}\n\n/**\n * TODO: docs\n */\nexport class Registry {\n\t/**\n\t * A map from the aliases of components to the id of the component with that alias.\n\t */\n\tprivate aliasMap = new Map<string, string>();\n\n\t/**\n\t * A map from the aliases of components to the id of the component with that alias.\n\t */\n\tprivate entries = new Map<string, Entry>();\n\n\tprivate Prism: Prism;\n\n\tconstructor (Prism: Prism) {\n\t\tthis.Prism = Prism;\n\t}\n\n\t/**\n\t * If the given name is a known alias, then the id of the component of the alias will be returned. Otherwise, the\n\t * `name` will be returned as is.\n\t */\n\tresolveAlias (name: string): string {\n\t\treturn this.aliasMap.get(name) ?? name;\n\t}\n\n\t/**\n\t * Returns whether this registry has a component with the given name or alias.\n\t */\n\thas (name: string): boolean {\n\t\treturn this.entries.has(this.resolveAlias(name));\n\t}\n\n\tadd (...components: ComponentProto[]): void {\n\t\tconst added = new Set<string>();\n\n\t\tconst register = (proto: ComponentProto) => {\n\t\t\tconst { id } = proto;\n\t\t\tif (this.entries.has(id)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.entries.set(id, { proto });\n\t\t\tadded.add(id);\n\n\t\t\t// add aliases\n\t\t\tforEach(proto.alias, alias => this.aliasMap.set(alias, id));\n\n\t\t\t// dependencies\n\t\t\tforEach(proto.require, register);\n\n\t\t\t// add plugin namespace\n\t\t\tif (proto.plugin) {\n\t\t\t\tthis.Prism.plugins[kebabToCamelCase(id)] = proto.plugin(this.Prism as never);\n\t\t\t}\n\t\t};\n\t\tcomponents.forEach(register);\n\n\t\tthis.update(added);\n\t}\n\n\tprivate update (changed: ReadonlySet<string>): void {\n\t\tconst updateCache = new Map<string, boolean>();\n\t\tconst idStack: string[] = [];\n\n\t\tconst performUpdateUncached = (id: string): boolean => {\n\t\t\t// check for circular dependencies\n\t\t\tconst circularStart = idStack.indexOf(id);\n\t\t\tif (circularStart !== idStack.length - 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Circular dependency ${idStack.slice(circularStart).join(' -> ')} not allowed`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// check whether the component is registered\n\t\t\tconst entry = this.entries.get(id);\n\t\t\tif (!entry) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check whether any dependencies updated\n\t\t\tif (!shouldRunEffects(entry.proto)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// reset\n\t\t\tentry.evaluatedGrammar = undefined;\n\t\t\tentry.evaluatedEffect?.();\n\n\t\t\t// redo effects\n\t\t\tentry.evaluatedEffect = entry.proto.effect?.(this.Prism as never);\n\n\t\t\treturn true;\n\t\t};\n\t\tconst performUpdate = (id: string): boolean => {\n\t\t\tlet status = updateCache.get(id);\n\t\t\tif (status === undefined) {\n\t\t\t\tidStack.push(id);\n\t\t\t\tstatus = performUpdateUncached(id);\n\t\t\t\tidStack.pop();\n\t\t\t\tupdateCache.set(id, status);\n\t\t\t}\n\t\t\treturn status;\n\t\t};\n\n\t\tconst shouldRunEffects = (proto: ComponentProto): boolean => {\n\t\t\tlet depsChanged = false;\n\n\t\t\tforEach(proto.require, ({ id }) => {\n\t\t\t\tif (performUpdate(id)) {\n\t\t\t\t\tdepsChanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tforEach(proto.optional, id => {\n\t\t\t\tif (performUpdate(this.resolveAlias(id))) {\n\t\t\t\t\tdepsChanged = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn depsChanged || changed.has(proto.id);\n\t\t};\n\n\t\tthis.entries.forEach((_, id) => performUpdate(id));\n\t}\n\n\tgetLanguage (id: string): Grammar | undefined {\n\t\tid = this.resolveAlias(id);\n\n\t\tconst entry = this.entries.get(id);\n\t\tconst grammar = entry?.proto.grammar;\n\t\tif (!grammar) {\n\t\t\t// we do not have the given component registered or the component doesn't define a grammar\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (entry.evaluatedGrammar) {\n\t\t\t// use the cached grammar\n\t\t\treturn entry.evaluatedGrammar;\n\t\t}\n\n\t\tif (typeof grammar === 'object') {\n\t\t\t// the grammar is a simple object, so we don't need to evaluate it\n\t\t\treturn (entry.evaluatedGrammar = grammar);\n\t\t}\n\n\t\tconst required = (id: string): Grammar => {\n\t\t\tconst grammar = this.getLanguage(id);\n\t\t\tif (!grammar) {\n\t\t\t\tthrow new Error(`The language ${id} was not found.`);\n\t\t\t}\n\t\t\treturn grammar;\n\t\t};\n\n\t\treturn (entry.evaluatedGrammar = grammar({\n\t\t\tgetLanguage: required,\n\t\t\tgetOptionalLanguage: id => this.getLanguage(id),\n\t\t\textend: (id, ref) => extend(required(id), id, ref),\n\t\t}));\n\t}\n}\n","// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { Grammar, GrammarToken, TokenName } from '../types';\n\nexport class Token {\n\t/**\n\t * The type of the token.\n\t *\n\t * This is usually the key of a pattern in a {@link Grammar}.\n\t *\n\t * @see {@link GrammarToken}\n\t */\n\ttype: TokenName;\n\t/**\n\t * The strings or tokens contained by this token.\n\t *\n\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t */\n\tcontent: string | TokenStream;\n\t/**\n\t * The alias(es) of the token.\n\t *\n\t * @see {@link GrammarToken#alias}\n\t */\n\talias?: TokenName | TokenName[];\n\n\t/**\n\t * Length of the full string this token was created from.\n\t *\n\t * Only used internally. The API does not guarantee that this field has any particular value or meaning.\n\t *\n\t * @internal\n\t */\n\tlength: number;\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param type See {@link Token#type}\n\t * @param content See {@link Token#content}\n\t * @param alias The alias(es) of the token.\n\t * @param matchedStr A copy of the full string this token was created from.\n\t * @public\n\t */\n\tconstructor (\n\t\ttype: TokenName,\n\t\tcontent: string | TokenStream,\n\t\talias?: TokenName | TokenName[],\n\t\tmatchedStr = ''\n\t) {\n\t\tthis.type = type;\n\t\tthis.content = content;\n\t\tthis.alias = alias;\n\t\tthis.length = matchedStr.length;\n\t}\n\n\t/**\n\t * Adds the given alias to the list of aliases of this token.\n\t */\n\taddAlias (alias: TokenName): void {\n\t\tlet aliases = this.alias;\n\t\tif (!aliases) {\n\t\t\tthis.alias = aliases = [];\n\t\t}\n\t\telse if (!Array.isArray(aliases)) {\n\t\t\tthis.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n */\nexport type TokenStream = (string | Token)[];\n\n/**\n * Returns the text content of the given token or token stream.\n */\nexport function getTextContent (token: string | Token | TokenStream): string {\n\tif (typeof token === 'string') {\n\t\treturn token;\n\t}\n\telse if (Array.isArray(token)) {\n\t\treturn token.map(getTextContent).join('');\n\t}\n\telse {\n\t\treturn getTextContent(token.content);\n\t}\n}\n","import { getLanguage, setLanguage } from '../shared/dom-util';\nimport { rest, tokenize } from '../shared/symbols';\nimport { htmlEncode } from '../shared/util';\nimport { HookState } from './hook-state';\nimport { Hooks } from './hooks';\nimport { LinkedList } from './linked-list';\nimport { Registry } from './registry';\nimport { Token } from './token';\nimport type { KnownPlugins } from '../known-plugins';\nimport type { Grammar, GrammarToken, GrammarTokens, RegExpLike } from '../types';\nimport type { HookEnvMap } from './hooks';\nimport type { LinkedListHeadNode, LinkedListMiddleNode, LinkedListTailNode } from './linked-list';\nimport type { TokenStream } from './token';\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n */\nexport class Prism {\n\thooks = new Hooks();\n\tcomponents = new Registry(this);\n\tplugins: Partial<Record<string, unknown> & KnownPlugins> = {};\n\n\t/**\n\t * This is the most high-level function in Prism’s API.\n\t * It queries all the elements that have a `.language-xxxx` class and then calls {@link Prism#highlightElement} on\n\t * each one of them.\n\t *\n\t * The following hooks will be run:\n\t * 1. `before-highlightall`\n\t * 2. `before-all-elements-highlight`\n\t * 3. All hooks of {@link Prism#highlightElement} for each element.\n\t */\n\thighlightAll (options: HighlightAllOptions = {}) {\n\t\tconst { root, async, callback } = options;\n\n\t\tconst env: HookEnvMap['before-highlightall'] | HookEnvMap['before-all-elements-highlight'] =\n\t\t\t{\n\t\t\t\tcallback,\n\t\t\t\troot: root ?? document,\n\t\t\t\tselector:\n\t\t\t\t\t'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code',\n\t\t\t\tstate: new HookState(),\n\t\t\t};\n\n\t\tthis.hooks.run('before-highlightall', env);\n\n\t\tassertEnv<'before-all-elements-highlight'>(env);\n\t\tenv.elements = [...env.root.querySelectorAll(env.selector)];\n\n\t\tthis.hooks.run('before-all-elements-highlight', env);\n\n\t\tfor (const element of env.elements) {\n\t\t\tthis.highlightElement(element, { async, callback: env.callback });\n\t\t}\n\t}\n\n\t/**\n\t * Highlights the code inside a single element.\n\t *\n\t * The following hooks will be run:\n\t * 1. `before-sanity-check`\n\t * 2. `before-highlight`\n\t * 3. All hooks of {@link Prism#highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t * 4. `before-insert`\n\t * 5. `after-highlight`\n\t * 6. `complete`\n\t *\n\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t * the element's language.\n\t *\n\t * @param element The element containing the code.\n\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t */\n\thighlightElement (element: Element, options: HighlightElementOptions = {}) {\n\t\tconst { async, callback } = options;\n\n\t\t// Find language\n\t\tconst language = getLanguage(element);\n\t\tconst languageId = this.components.resolveAlias(language);\n\t\tconst grammar = this.components.getLanguage(languageId);\n\n\t\t// Set language on the element, if not present\n\t\tsetLanguage(element, language);\n\n\t\t// Set language on the parent, for styling\n\t\tlet parent = element.parentElement;\n\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\tsetLanguage(parent, language);\n\t\t}\n\n\t\tconst code = element.textContent as string;\n\n\t\tconst env: HookEnvMap['before-sanity-check'] = {\n\t\t\telement,\n\t\t\tlanguage,\n\t\t\tgrammar,\n\t\t\tcode,\n\t\t\tstate: new HookState(),\n\t\t};\n\n\t\tconst insertHighlightedCode = (highlightedCode: string) => {\n\t\t\tassertEnv<'before-insert'>(env);\n\t\t\tenv.highlightedCode = highlightedCode;\n\t\t\tthis.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tthis.hooks.run('after-highlight', env);\n\t\t\tthis.hooks.run('complete', env);\n\t\t\tcallback?.(env.element);\n\t\t};\n\n\t\tthis.hooks.run('before-sanity-check', env);\n\n\t\t// plugins may change/add the parent/element\n\t\tparent = env.element.parentElement;\n\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\tparent.setAttribute('tabindex', '0');\n\t\t}\n\n\t\tif (!env.code) {\n\t\t\tthis.hooks.run('complete', env);\n\t\t\tcallback?.(env.element);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hooks.run('before-highlight', env);\n\n\t\tif (!env.grammar) {\n\t\t\tinsertHighlightedCode(htmlEncode(env.code));\n\t\t\treturn;\n\t\t}\n\n\t\tif (async) {\n\t\t\tasync({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code,\n\t\t\t\tgrammar: env.grammar,\n\t\t\t}).then(insertHighlightedCode, error => console.log(error));\n\t\t}\n\t\telse {\n\t\t\tinsertHighlightedCode(this.highlight(env.code, env.language, { grammar: env.grammar }));\n\t\t}\n\t}\n\n\t/**\n\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t * and the language definitions to use, and returns a string with the HTML produced.\n\t *\n\t * The following hooks will be run:\n\t * 1. `before-tokenize`\n\t * 2. `after-tokenize`\n\t * 3. `wrap`: On each {@link Token}.\n\t *\n\t * @param text A string with the code to be highlighted.\n\t * @param language The name of the language definition passed to `grammar`.\n\t * @param options An object containing the tokens to use.\n\t *\n\t * Usually a language definition like `Prism.languages.markup`.\n\t * @returns The highlighted HTML.\n\t * @example\n\t * Prism.highlight('var foo = true;', 'javascript');\n\t */\n\thighlight (text: string, language: string, options?: HighlightOptions): string {\n\t\tconst languageId = this.components.resolveAlias(language);\n\t\tconst grammar = options?.grammar ?? this.components.getLanguage(languageId);\n\n\t\tconst env: HookEnvMap['before-tokenize'] | HookEnvMap['after-tokenize'] = {\n\t\t\tcode: text,\n\t\t\tgrammar,\n\t\t\tlanguage,\n\t\t};\n\t\tthis.hooks.run('before-tokenize', env);\n\t\tif (!env.grammar) {\n\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t}\n\n\t\tassertEnv<'after-tokenize'>(env);\n\t\tenv.tokens = this.tokenize(env.code, env.grammar);\n\t\tthis.hooks.run('after-tokenize', env);\n\n\t\treturn stringify(env.tokens, env.language, this.hooks);\n\t}\n\n\t/**\n\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t * and the language definitions to use, and returns an array with the tokenized code.\n\t *\n\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t *\n\t * This method could be useful in other contexts as well, as a very crude parser.\n\t *\n\t * @param text A string with the code to be highlighted.\n\t * @param grammar An object containing the tokens to use.\n\t *\n\t * Usually a language definition like `Prism.languages.markup`.\n\t * @returns An array of strings and tokens, a token stream.\n\t * @example\n\t * let code = `var foo = 0;`;\n\t * let tokens = Prism.tokenize(code, Prism.getLanguage('javascript'));\n\t * tokens.forEach(token => {\n\t *     if (token instanceof Token && token.type === 'number') {\n\t *         console.log(`Found numeric literal: ${token.content}`);\n\t *     }\n\t * });\n\t */\n\ttokenize (text: string, grammar: Grammar): TokenStream {\n\t\tconst customTokenize = grammar[tokenize];\n\t\tif (customTokenize) {\n\t\t\treturn customTokenize(text, grammar, this);\n\t\t}\n\n\t\tlet restGrammar = resolve(this.components, grammar[rest]);\n\t\twhile (restGrammar) {\n\t\t\tgrammar = { ...grammar, ...restGrammar };\n\t\t\trestGrammar = resolve(this.components, restGrammar[rest]);\n\t\t}\n\n\t\tconst tokenList = new LinkedList<string | Token>();\n\t\ttokenList.addAfter(tokenList.head, text);\n\n\t\tthis._matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\treturn tokenList.toArray();\n\t}\n\n\tprivate _matchGrammar (\n\t\ttext: string,\n\t\ttokenList: LinkedList<string | Token>,\n\t\tgrammar: GrammarTokens,\n\t\tstartNode: LinkedListHeadNode<string | Token> | LinkedListMiddleNode<string | Token>,\n\t\tstartPos: number,\n\t\trematch?: RematchOptions\n\t): void {\n\t\tfor (const token in grammar) {\n\t\t\tconst tokenValue = grammar[token];\n\t\t\tif (!grammar.hasOwnProperty(token) || !tokenValue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst patterns = Array.isArray(tokenValue) ? tokenValue : [tokenValue];\n\n\t\t\tfor (let j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause === `${token},${j}`) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst patternObj = toGrammarToken(patterns[j]);\n\t\t\t\tlet { pattern, lookbehind = false, greedy = false, alias, inside } = patternObj;\n\t\t\t\tconst insideGrammar = resolve(this.components, inside);\n\n\t\t\t\tif (greedy && !pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tpatternObj.pattern = pattern = RegExp(pattern.source, pattern.flags + 'g');\n\t\t\t\t}\n\n\t\t\t\tfor (\n\t\t\t\t\t// iterate the token list and keep track of the current token/string position\n\t\t\t\t\tlet currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode.next !== null;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tlet match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst from = match.index;\n\t\t\t\t\t\tconst to = match.index + match[0].length;\n\t\t\t\t\t\tlet p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tif (currentNode.next === null) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t'The linked list and the actual text have become de-synced'\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tlet k:\n\t\t\t\t\t\t\t| LinkedListMiddleNode<Token | string>\n\t\t\t\t\t\t\t| LinkedListTailNode<Token | string> = currentNode;\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tk.next !== null && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tconst from = match.index;\n\t\t\t\t\tconst matchStr = match[0];\n\t\t\t\t\tconst before = str.slice(0, from);\n\t\t\t\t\tconst after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tconst reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = tokenList.addAfter(removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenList.removeRange(removeFrom, removeCount);\n\n\t\t\t\t\tconst wrapped = new Token(\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t\tinsideGrammar ? this.tokenize(matchStr, insideGrammar) : matchStr,\n\t\t\t\t\t\talias,\n\t\t\t\t\t\tmatchStr\n\t\t\t\t\t);\n\t\t\t\t\tcurrentNode = tokenList.addAfter(removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\ttokenList.addAfter(currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\tconst nestedRematch: RematchOptions = {\n\t\t\t\t\t\t\tcause: `${token},${j}`,\n\t\t\t\t\t\t\treach,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._matchGrammar(\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\ttokenList,\n\t\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\t\tcurrentNode.prev,\n\t\t\t\t\t\t\tpos,\n\t\t\t\t\t\t\tnestedRematch\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface RematchOptions {\n\tcause: string;\n\treach: number;\n}\n\nexport interface AsyncHighlightingData {\n\tlanguage: string;\n\tcode: string;\n\tgrammar: Grammar;\n}\nexport type AsyncHighlighter = (data: AsyncHighlightingData) => Promise<string>;\n\nexport interface HighlightAllOptions {\n\t/**\n\t * The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t */\n\troot?: ParentNode;\n\tasync?: AsyncHighlighter;\n\t/**\n\t * An optional callback to be invoked on each element after its highlighting is done.\n\t *\n\t * @see HighlightElementOptions#callback\n\t */\n\tcallback?: (element: Element) => void;\n}\n\nexport interface HighlightElementOptions {\n\tasync?: AsyncHighlighter;\n\t/**\n\t * An optional callback to be invoked after the highlighting is done.\n\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t *\n\t * @param element The element successfully highlighted.\n\t */\n\tcallback?: (element: Element) => void;\n}\n\nexport interface HighlightOptions {\n\tgrammar?: Grammar;\n}\n\nfunction assertEnv<T extends keyof HookEnvMap> (_env: unknown): asserts _env is HookEnvMap[T] {\n\t/* noop */\n}\n\nfunction matchPattern (pattern: RegExp, pos: number, text: string, lookbehind: boolean) {\n\tpattern.lastIndex = pos;\n\tconst match = pattern.exec(text);\n\tif (match && lookbehind && match[1]) {\n\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\tconst lookbehindLength = match[1].length;\n\t\tmatch.index += lookbehindLength;\n\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t}\n\treturn match;\n}\n\n/**\n * Converts the given token or token stream to an HTML representation.\n *\n * The following hooks will be run:\n * 1. `wrap`: On each {@link Token}.\n *\n * @param o The token or token stream to be converted.\n * @param language The name of current language.\n * @returns The HTML representation of the token or token stream.\n */\nfunction stringify (o: string | Token | TokenStream, language: string, hooks: Hooks): string {\n\tif (typeof o === 'string') {\n\t\treturn htmlEncode(o);\n\t}\n\tif (Array.isArray(o)) {\n\t\tlet s = '';\n\t\to.forEach(e => {\n\t\t\ts += stringify(e, language, hooks);\n\t\t});\n\t\treturn s;\n\t}\n\n\tconst env: HookEnvMap['wrap'] = {\n\t\ttype: o.type,\n\t\tcontent: stringify(o.content, language, hooks),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage,\n\t};\n\n\tconst aliases = o.alias;\n\tif (aliases) {\n\t\tif (Array.isArray(aliases)) {\n\t\t\tenv.classes.push(...aliases);\n\t\t}\n\t\telse {\n\t\t\tenv.classes.push(aliases);\n\t\t}\n\t}\n\n\thooks.run('wrap', env);\n\n\tlet attributes = '';\n\tfor (const name in env.attributes) {\n\t\tattributes +=\n\t\t\t' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t}\n\n\treturn (\n\t\t'<' +\n\t\tenv.tag +\n\t\t' class=\"' +\n\t\tenv.classes.join(' ') +\n\t\t'\"' +\n\t\tattributes +\n\t\t'>' +\n\t\tenv.content +\n\t\t'</' +\n\t\tenv.tag +\n\t\t'>'\n\t);\n}\n\nfunction toGrammarToken (pattern: GrammarToken | RegExpLike): GrammarToken {\n\tif (!pattern.pattern) {\n\t\treturn { pattern };\n\t}\n\telse {\n\t\treturn pattern;\n\t}\n}\n\nfunction resolve (\n\tcomponents: Registry,\n\treference: Grammar | string | null | undefined\n): Grammar | undefined {\n\tif (reference) {\n\t\tif (typeof reference === 'string') {\n\t\t\treturn components.getLanguage(reference);\n\t\t}\n\t\treturn reference;\n\t}\n\treturn undefined;\n}\n","import { Prism } from './core/prism';\n\nconst globalSymbol = Symbol.for('Prism global');\n\n// eslint-disable-next-line no-undef\nconst namespace = globalThis as Partial<Record<typeof globalSymbol, Prism>>;\nconst globalPrism = (namespace[globalSymbol] ??= new Prism());\n\n/**\n * The global {@link Prism} instance.\n *\n * This instance of Prism is unique. Even if this module is imported from\n * different sources, the same Prism instance will be returned.\n */\nexport default globalPrism;\n","import type { LanguageProto } from '../types';\n\nexport default {\n\tid: 'plain',\n\talias: ['text', 'txt', 'plaintext'],\n\tgrammar: {},\n} as LanguageProto<'plain'>;\n","import type { LanguageProto } from '../types';\n\nexport default {\n\tid: 'regex',\n\tgrammar () {\n\t\tconst specialEscape = {\n\t\t\tpattern: /\\\\[\\\\(){}[\\]^$+*?|.]/,\n\t\t\talias: 'escape',\n\t\t};\n\t\tconst escape =\n\t\t\t/\\\\(?:x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]+\\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;\n\t\tconst charSet = {\n\t\t\tpattern: /\\.|\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n\t\t\talias: 'class-name',\n\t\t};\n\t\tconst charSetWithoutDot = {\n\t\t\tpattern: /\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n\t\t\talias: 'class-name',\n\t\t};\n\n\t\tconst rangeChar = '(?:[^\\\\\\\\-]|' + escape.source + ')';\n\t\tconst range = RegExp(rangeChar + '-' + rangeChar);\n\n\t\t// the name of a capturing group\n\t\tconst groupName = {\n\t\t\tpattern: /(<|')[^<>']+(?=[>']$)/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'variable',\n\t\t};\n\n\t\treturn {\n\t\t\t'char-class': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\\\\\)*)\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'char-class-negation': {\n\t\t\t\t\t\tpattern: /(^\\[)\\^/,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'operator',\n\t\t\t\t\t},\n\t\t\t\t\t'char-class-punctuation': {\n\t\t\t\t\t\tpattern: /^\\[|\\]$/,\n\t\t\t\t\t\talias: 'punctuation',\n\t\t\t\t\t},\n\t\t\t\t\t'range': {\n\t\t\t\t\t\tpattern: range,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'escape': escape,\n\t\t\t\t\t\t\t'range-punctuation': {\n\t\t\t\t\t\t\t\tpattern: /-/,\n\t\t\t\t\t\t\t\talias: 'operator',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t'special-escape': specialEscape,\n\t\t\t\t\t'char-set': charSetWithoutDot,\n\t\t\t\t\t'escape': escape,\n\t\t\t\t},\n\t\t\t},\n\t\t\t'special-escape': specialEscape,\n\t\t\t'char-set': charSet,\n\t\t\t'backreference': [\n\t\t\t\t{\n\t\t\t\t\t// a backreference which is not an octal escape\n\t\t\t\t\tpattern: /\\\\(?![123][0-7]{2})[1-9]/,\n\t\t\t\t\talias: 'keyword',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /\\\\k<[^<>']+>/,\n\t\t\t\t\talias: 'keyword',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'group-name': groupName,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\t'anchor': {\n\t\t\t\tpattern: /[$^]|\\\\[ABbGZz]/,\n\t\t\t\talias: 'function',\n\t\t\t},\n\t\t\t'escape': escape,\n\t\t\t'group': [\n\t\t\t\t{\n\t\t\t\t\t// https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html\n\t\t\t\t\t// https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs\n\n\t\t\t\t\t// (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)\n\t\t\t\t\tpattern:\n\t\t\t\t\t\t/\\((?:\\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,\n\t\t\t\t\talias: 'punctuation',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'group-name': groupName,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /\\)/,\n\t\t\t\t\talias: 'punctuation',\n\t\t\t\t},\n\t\t\t],\n\t\t\t'quantifier': {\n\t\t\t\tpattern: /(?:[+*?]|\\{\\d+(?:,\\d*)?\\})[?+]?/,\n\t\t\t\talias: 'number',\n\t\t\t},\n\t\t\t'alternation': {\n\t\t\t\tpattern: /\\|/,\n\t\t\t\talias: 'keyword',\n\t\t\t},\n\t\t};\n\t},\n} as LanguageProto<'regex'>;\n","import type { GrammarToken, LanguageProto, Grammar } from '../types'\n\n// --------------------------------------------------------------------------\n\nconst boolExp = /\\b(?:AND|NOT|OR|PROX)\\b/i\nconst stringExp = /(?:\"(?:\\\\[\\s\\S]|(?!\")[^\\\\])*\")/\nconst wordExp = /[^\\s()=<>\"/]+/\nconst identifierExp = RegExp('(?:' + stringExp.source + '|' + wordExp.source + ')')\n\nconst comparitorNamedExp = identifierExp\nconst comparitorSymbolExp = /(?:<>|[=><]=?)/\nconst comparitorExp = RegExp(\n  '(?:' + comparitorSymbolExp.source + '|' + comparitorNamedExp.source + ')'\n)\n\nconst modifierExp = RegExp(\n  '/\\\\s*' +\n    identifierExp.source +\n    '(?:\\\\s*' +\n    comparitorSymbolExp.source +\n    '\\\\s*' +\n    identifierExp.source +\n    ')?'\n)\nconst modifierListExp = RegExp('(?:\\\\s*' + modifierExp.source + ')*')\n\nconst relationExp = RegExp(comparitorExp.source + modifierListExp.source)\n\n// --------------------------------------------------------------------------\n\nconst modifier = {\n  pattern: modifierExp,\n  inside: {\n    modifier: {\n      pattern: RegExp('(/\\\\s*)' + identifierExp.source),\n      lookbehind: true,\n      alias: 'property',\n    } as GrammarToken,\n    value: {\n      pattern: RegExp(identifierExp.source + '$'),\n      alias: 'string',\n    } as GrammarToken,\n    comparitor: {\n      pattern: comparitorSymbolExp,\n      alias: 'operator',\n    } as GrammarToken,\n    punctuation: /\\//,\n  } as Grammar,\n} as GrammarToken\n\nconst searchClause = {\n  pattern: RegExp(\n    '(?:' + identifierExp.source + '\\\\s*' + relationExp.source + '\\\\s*)?' + identifierExp.source\n  ),\n  inside: {\n    // required last part, search term\n    term: {\n      pattern: RegExp(identifierExp.source + '(?!.)'),\n      alias: 'string',\n    } as GrammarToken,\n    // optional index with relation\n    index: {\n      pattern: RegExp('^' + identifierExp.source),\n      alias: 'property',\n    } as GrammarToken,\n    'relation-modifier': modifier,\n    relation: {\n      pattern: comparitorExp,\n      alias: 'operator',\n    } as GrammarToken,\n  } as Grammar,\n} as GrammarToken\n\nconst boolClause = {\n  pattern: RegExp(boolExp.source + modifierListExp.source, 'i'),\n  inside: {\n    boolean: {\n      pattern: boolExp,\n      alias: 'operator',\n    } as GrammarToken,\n    'boolean-modifier': modifier,\n  } as Grammar,\n} as GrammarToken\n\nconst prefix = {\n  pattern: RegExp('(^\\\\s*)>\\\\s*(?:' + identifierExp.source + '\\\\s*=\\\\s*)?' + identifierExp.source),\n  lookbehind: true,\n  inside: {\n    uri: {\n      pattern: RegExp(identifierExp.source + '$'),\n      alias: 'string',\n    } as GrammarToken,\n    prefix: {\n      pattern: identifierExp,\n      alias: 'property',\n    } as GrammarToken,\n    punctuation: /[>=]/,\n  } as Grammar,\n} as GrammarToken\n\nconst sortby = {\n  // XXX: too complex exponential/polynomial backtracking possible ...\n  //pattern: RegExp('sortby(?:\\\\s*' + identifierExp.source + modifierListExp.source + ')+\\\\s*$', 'i'),\n  pattern: RegExp('(^|\\\\s)sortby\\\\b(?:' + identifierExp.source + '\\\\b|[\\\\s=></])+$', 'i'),\n  inside: {\n    keyword: /sortby/i,\n    'sortby-index-modifier': modifier,\n    index: {\n      pattern: identifierExp,\n      alias: 'property',\n    } as GrammarToken,\n  } as Grammar,\n} as GrammarToken\n\n// --------------------------------------------------------------------------\n\nexport default {\n  id: 'cql',\n  grammar: () =>\n    ({\n      // prefix / suffix\n      prefix: prefix,\n      sortby: sortby,\n\n      // conjuctions\n      'bool-group': boolClause,\n      // search clause triples\n      'search-clause': searchClause,\n\n      // grouping\n      punctuation: /[()]/,\n    } as Grammar),\n} as LanguageProto<'cql'>\n","import type { LanguageProto } from '../types'\n\n// --------------------------------------------------------------------------\n\nexport default {\n  id: 'fcs-cql',\n  grammar: () => ({\n    punctuation: /[()]/,\n    operator: {\n      // we want at least something before the operator to have it considered a operator\n      pattern: /(\\S\\s)\\b(?:AND|OR)\\b/i,\n      greedy: true,\n      lookbehind: true,\n    },\n    string: {\n      pattern: /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n      greedy: true,\n    },\n    // any non-quoted word (without whitespaces) is also a string technically\n    'string-unquoted': {\n      pattern: /\\S+/,\n      alias: 'string',\n    },\n  }),\n} as LanguageProto<'fcs-cql'>\n","import type { LanguageProto } from '../types'\n\n// --------------------------------------------------------------------------\n\nconst identifierExp = /[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?/\n\nconst attributeExp = RegExp(\n  '\\\\b(?:' + identifierExp.source + ':)?(?:' + identifierExp.source + ')\\\\b(?=\\\\s*[!=])'\n)\n// /\\b(?:[a-zA-Z][a-zA-Z0-9-]*:)?(?:[a-zA-Z][a-zA-Z0-9-]*)\\b(?=\\s*[!=])/\n\nconst stringExp = /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/\nconst regexpFlagExp = /\\/(?:[iIcCld]+)/\nconst expressionTripleOperatorExp = /=|!=/\n\n// --------------------------------------------------------------------------\n\nconst string = {\n  pattern: stringExp,\n  alias: 'regex',\n  // optional deep analysis\n  inside: {\n    escape: /\\\\(?:[\\\\'\"nt.^$*+?(){[|]|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{2})/,\n    'invalid-escape': /\\\\[\\s\\S]/,\n    whitespace:\n      // eslint-disable-next-line no-control-regex\n      /\\u0009|\\u000A|\\u000B|\\u000C|\\u000D|\\u0020|\\u0085|\\u00A0|\\u1680|\\u2000|\\u2001|\\u2002|\\u2003|\\u2004|\\u2005|\\u2006|\\u2007|\\u2008|\\u2009|\\u200A|\\u2028|\\u2029|\\u202F|\\u205F|\\u3000/,\n  },\n}\n\nconst regexpFlag = {\n  pattern: regexpFlagExp,\n  inside: {\n    punctuation: /\\//,\n    keyword: /\\w/,\n  },\n}\n\nconst expressionTriple = {\n  pattern: RegExp(\n    attributeExp.source +\n      '\\\\s*(?:' +\n      expressionTripleOperatorExp.source +\n      ')\\\\s*' +\n      stringExp.source +\n      '(?:\\\\s*' +\n      regexpFlagExp.source +\n      ')?'\n  ),\n  inside: {\n    attribute: {\n      pattern: attributeExp,\n      alias: 'property',\n      inside: {\n        qualifier: {\n          pattern: RegExp(identifierExp.source + '(?=:)'),\n          alias: 'class-name',\n        },\n        punctuation: /:/,\n        identifier: {\n          pattern: identifierExp,\n          alias: 'class-name',\n        },\n      },\n    },\n    regexp: string,\n    operator: expressionTripleOperatorExp,\n    'regexp-flag': regexpFlag,\n  },\n}\n\n// --------------------------------------------------------------------------\n\nexport default {\n  id: 'fcs-fcsql',\n  grammar: () => ({\n    // segment query\n    segment: {\n      pattern: /\\[.*?(?:[|&()=]\\s*(?:(\"|')(\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1)[^\\]=]*?)*\\]/,\n      // pattern: /(?:\\[.*?)(?:[=|&()]\\s*(\"|')(\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1[^\\]=]*?)*\\]/,\n      //pattern: /\\[(.*?)\\]/,\n      inside: {\n        'basic-expression': expressionTriple,\n        'invalid-expression': stringExp,\n        operator: /[!&|]/,\n        punctuation: /[()[\\]]/,\n      },\n    },\n    // implicit query (string outside explicit token \"[...]\")\n    string: string,\n    // quantifier for segment, string or group\n    quantifier: {\n      pattern: /(?:[*+?])|\\{(?:\\d+|\\d+,|,\\d+|\\d+,\\d+)\\}/,\n      alias: 'operator',\n      inside: {\n        number: /\\d+/,\n        punctuation: /[{},]/,\n      },\n    },\n    'regexp-flag': regexpFlag,\n    // global \"within\" qualifier\n    within: {\n      pattern: /within\\s+\\b(?:p|paragraph|s|sentence|session|t|text|turn|u|utterance)\\b/,\n      inside: {\n        keyword: /\\w+/,\n      },\n    },\n    operator: /\\|/,\n    punctuation: /[{}[\\](),]/,\n  }),\n} as LanguageProto<'fcs-fcsql'>\n","import type { GrammarToken, LanguageProto } from '../types'\nimport cql from './prism-cql'\n\n// --------------------------------------------------------------------------\n\ntype BoolGroupInside = Record<'boolean', GrammarToken>\ntype SearchClauseInside = Record<'relation' | 'index' | 'relation-modifier', GrammarToken>\ntype RelationModifierInside = Record<'modifier' | 'comparitor', GrammarToken>\n\n// --------------------------------------------------------------------------\n\nconst BOOLEAN_OPERATORS = ['AND', 'NOT', 'OR'] as const\n\nconst INDEXES = [\n  'antonym',\n  'baseform',\n  'case',\n  'citation',\n  'definition',\n  'entryId',\n  'etymology',\n  'frequency',\n  'gender',\n  'holonym',\n  'hypernym',\n  'hyponym',\n  'lang',\n  'lemma',\n  'meronym',\n  'number',\n  'phonetic',\n  'pos',\n  'ref',\n  'related',\n  'segmentation',\n  'senseRef',\n  'sentiment',\n  'subordinate',\n  'superordinate',\n  'synonym',\n  'transcription',\n  'translation',\n] as const\n\nconst RELATION_MODIFIERS = [\n  'fullMatch',\n  'honorWhitespace',\n  'ignoreAccents',\n  'ignoreCase',\n  'lang',\n  'masked',\n  'partialMatch',\n  'regexp',\n  'respectAccents',\n  'respectCase',\n  'unmasked',\n] as const\n\n// --------------------------------------------------------------------------\n\nexport default {\n  id: 'fcs-lexcql',\n  require: cql,\n  grammar({ extend }) {\n    // base on CQL language\n    const lexcql = extend('cql', {})\n\n    // constructs not used in LexCQL\n    delete lexcql['prefix']\n    delete lexcql['sortby']\n\n    // TODO: or do we want to add patterns for valid tokens first and invalid variants second (to support custom highlighting?)\n\n    const boolGroupInside = (lexcql['bool-group'] as GrammarToken).inside as BoolGroupInside\n    const searchClauseInside = (lexcql['search-clause'] as GrammarToken)\n      .inside as SearchClauseInside\n    const relationModifierInside = searchClauseInside['relation-modifier']\n      .inside as RelationModifierInside\n\n    // only some subset of bool expressions used\n    const boolExp = RegExp('\\\\b(?:' + BOOLEAN_OPERATORS.toSorted().join('|') + ')\\\\b', 'i')\n    boolGroupInside['boolean'].pattern = boolExp\n\n    // restrict relations in search clauses (XXX: support of negative look behind?)\n    const comparitorExp = /(?:(?:<>|(?<!<|>)==?)(?![=><])|\\b(?:exact|is|scr)\\b)/\n    searchClauseInside['relation'].pattern = comparitorExp\n\n    // restrict to known fields (index) in search clause\n    const fieldExp = RegExp('^\\\\b(?:' + INDEXES.toSorted().join('|') + ')\\\\b')\n    searchClauseInside['index'].pattern = fieldExp\n\n    // restrict relation modifiers in search clause\n    const modifierExp = RegExp('(/\\\\s*)(?:' + RELATION_MODIFIERS.toSorted().join('|') + ')')\n    relationModifierInside['modifier'].pattern = modifierExp\n    relationModifierInside['comparitor'].pattern = /=/\n\n    return lexcql\n  },\n} as LanguageProto<'fcs-lexcql'>\n","import { getParentPre, isActive } from '../../shared/dom-util';\nimport type { PluginProto } from '../../types';\n\nexport default {\n\tid: 'match-braces',\n\teffect(Prism) {\n\t\tfunction mapClassName(name: string) {\n\t\t\tconst customClass = Prism.plugins.customClass;\n\t\t\tif (customClass) {\n\t\t\t\treturn customClass.apply(name);\n\t\t\t} else {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\tconst PARTNER = {\n\t\t\t'(': ')',\n\t\t\t'[': ']',\n\t\t\t'{': '}',\n\t\t};\n\n\t\t// The names for brace types.\n\t\t// These names have two purposes: 1) they can be used for styling and 2) they are used to pair braces. Only braces\n\t\t// of the same type are paired.\n\t\tconst NAMES = {\n\t\t\t'(': 'brace-round',\n\t\t\t'[': 'brace-square',\n\t\t\t'{': 'brace-curly',\n\t\t};\n\n\t\t// A map for brace aliases.\n\t\t// This is useful for when some braces have a prefix/suffix as part of the punctuation token.\n\t\tconst BRACE_ALIAS_MAP: Readonly<Record<string, string>> = {\n\t\t\t'${': '{', // JS template punctuation (e.g. `foo ${bar + 1}`)\n\t\t};\n\n\t\tconst LEVEL_WARP = 12;\n\n\t\tlet pairIdCounter = 0;\n\n\t\tconst BRACE_ID_PATTERN = /^(pair-\\d+-)(close|open)$/;\n\n\t\t/**\n\t\t * Returns the brace partner given one brace of a brace pair.\n\t\t */\n\t\tfunction getPartnerBrace(brace: Element) {\n\t\t\tconst match = BRACE_ID_PATTERN.exec(brace.id);\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn document.querySelector('#' + match[1] + (match[2] === 'open' ? 'close' : 'open'));\n\t\t}\n\n\t\tfunction hoverBrace(this: Element) {\n\t\t\tif (!isActive(this, 'brace-hover', true)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst partner = getPartnerBrace(this);\n\t\t\tif (!partner) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t[this, partner].forEach((e) => {\n\t\t\t\te.classList.add(mapClassName('brace-hover'));\n\t\t\t});\n\t\t}\n\t\tfunction leaveBrace(this: Element) {\n\t\t\tconst partner = getPartnerBrace(this);\n\t\t\tif (!partner) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t[this, partner].forEach((e) => {\n\t\t\t\te.classList.remove(mapClassName('brace-hover'));\n\t\t\t});\n\t\t}\n\t\tfunction clickBrace(this: Element) {\n\t\t\tif (!isActive(this, 'brace-select', true)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst partner = getPartnerBrace(this);\n\t\t\tif (!partner) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t[this, partner].forEach((e) => {\n\t\t\t\te.classList.add(mapClassName('brace-selected'));\n\t\t\t});\n\t\t}\n\n\t\tconst withEventListener = new WeakSet<Element>();\n\n\t\treturn Prism.hooks.add('complete', (env) => {\n\t\t\tconst code = env.element;\n\n\t\t\tconst pre = getParentPre(code);\n\t\t\tif (!pre) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// find the braces to match\n\t\t\tconst toMatch: (keyof typeof PARTNER)[] = [];\n\t\t\tif (isActive(code, 'match-braces')) {\n\t\t\t\ttoMatch.push('(', '[', '{');\n\t\t\t}\n\n\t\t\tif (toMatch.length === 0) {\n\t\t\t\t// nothing to match\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!withEventListener.has(pre)) {\n\t\t\t\t// code blocks might be highlighted more than once\n\t\t\t\twithEventListener.add(pre);\n\t\t\t\tpre.addEventListener('mousedown', () => {\n\t\t\t\t\t// the code element might have been replaced\n\t\t\t\t\tconst code = pre.querySelector('code');\n\t\t\t\t\tconst className = mapClassName('brace-selected');\n\t\t\t\t\tcode?.querySelectorAll('.' + className).forEach((e) => {\n\t\t\t\t\t\te.classList.remove(className);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst punctuation = [...code.querySelectorAll('span.' + mapClassName('token') + '.' + mapClassName('punctuation'))];\n\n\t\t\tconst allBraces: { index: number, open: boolean, element: Element }[] = [];\n\n\t\t\ttoMatch.forEach((open) => {\n\t\t\t\tconst close = PARTNER[open];\n\t\t\t\tconst name = mapClassName(NAMES[open]);\n\n\t\t\t\tconst pairs: [number, number][] = [];\n\t\t\t\tconst openStack: number[] = [];\n\n\t\t\t\tfor (let i = 0; i < punctuation.length; i++) {\n\t\t\t\t\tconst element = punctuation[i];\n\t\t\t\t\tif (element.childElementCount === 0) {\n\t\t\t\t\t\tlet text = element.textContent || '';\n\t\t\t\t\t\ttext = BRACE_ALIAS_MAP[text] || text;\n\t\t\t\t\t\tif (text === open) {\n\t\t\t\t\t\t\tallBraces.push({ index: i, open: true, element });\n\t\t\t\t\t\t\telement.classList.add(name);\n\t\t\t\t\t\t\telement.classList.add(mapClassName('brace-open'));\n\t\t\t\t\t\t\topenStack.push(i);\n\t\t\t\t\t\t} else if (text === close) {\n\t\t\t\t\t\t\tallBraces.push({ index: i, open: false, element });\n\t\t\t\t\t\t\telement.classList.add(name);\n\t\t\t\t\t\t\telement.classList.add(mapClassName('brace-close'));\n\t\t\t\t\t\t\tconst popped = openStack.pop();\n\t\t\t\t\t\t\tif (popped !== undefined) {\n\t\t\t\t\t\t\t\tpairs.push([i, popped]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpairs.forEach((pair) => {\n\t\t\t\t\tconst pairId = `pair-${pairIdCounter++}-`;\n\n\t\t\t\t\tconst opening = punctuation[pair[0]];\n\t\t\t\t\tconst closing = punctuation[pair[1]];\n\n\t\t\t\t\topening.id = pairId + 'open';\n\t\t\t\t\tclosing.id = pairId + 'close';\n\n\t\t\t\t\t[opening, closing].forEach((e) => {\n\t\t\t\t\t\te.addEventListener('mouseenter', hoverBrace);\n\t\t\t\t\t\te.addEventListener('mouseleave', leaveBrace);\n\t\t\t\t\t\te.addEventListener('click', clickBrace);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tlet level = 0;\n\t\t\tallBraces.sort((a, b) => a.index - b.index);\n\t\t\tallBraces.forEach((brace) => {\n\t\t\t\tif (brace.open) {\n\t\t\t\t\tbrace.element.classList.add(mapClassName(`brace-level-${level % LEVEL_WARP + 1}`));\n\t\t\t\t\tlevel++;\n\t\t\t\t} else {\n\t\t\t\t\tlevel = Math.max(0, level - 1);\n\t\t\t\t\tbrace.element.classList.add(mapClassName(`brace-level-${level % LEVEL_WARP + 1}`));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n} as PluginProto<'match-braces'>;\n","import Prism from './global'\n\nimport plain from './languages/prism-plain'\nimport regex from './languages/prism-regex'\n\nimport cql from './languages/prism-cql'\nimport fcsCql from './languages/prism-fcs-cql'\nimport fcsFcsql from './languages/prism-fcs-fcsql'\nimport fcsLexcql from './languages/prism-fcs-lexcql'\n\nimport matchBraces from './plugins/match-braces/prism-match-braces'\n\nconst languages = [plain, regex, cql, fcsCql, fcsFcsql, fcsLexcql] as const\nconst plugins = [matchBraces] as const\n\nPrism.components.add(...languages)\nPrism.components.add(...plugins)\n\nexport default Prism\n"],"names":["lang","getLanguage","element","m","setLanguage","language","isActive","className","defaultActivation","getParentPre","pre","rest","tokenize","htmlEncode","text","forEach","value","callbackFn","capitalize","string","kebabToCamelCase","kebab","first","others","HookState","key","defaultValue","current","Hooks","name","callback","hooks","list","index","env","callbacks","LinkedList","head","tail","node","next","newNode","count","i","array","extend","grammar","id","reDef","cloneGrammar","result","visited","cloneToken","copy","cloneRef","cloneTokens","ref","clone","mapped","tokens","r","t","Registry","Prism","components","added","register","proto","alias","changed","updateCache","idStack","performUpdateUncached","circularStart","entry","shouldRunEffects","performUpdate","status","depsChanged","_","required","Token","type","content","matchedStr","aliases","options","root","async","languageId","parent","code","insertHighlightedCode","highlightedCode","error","stringify","customTokenize","restGrammar","resolve","tokenList","startNode","startPos","rematch","token","tokenValue","patterns","j","patternObj","toGrammarToken","pattern","lookbehind","greedy","inside","insideGrammar","currentNode","pos","str","removeCount","match","matchPattern","from","to","p","k","matchStr","before","after","reach","removeFrom","wrapped","nestedRematch","lookbehindLength","o","s","e","attributes","reference","globalSymbol","namespace","globalPrism","plain","regex","specialEscape","escape","charSet","charSetWithoutDot","rangeChar","range","groupName","boolExp","stringExp","wordExp","identifierExp","comparitorNamedExp","comparitorSymbolExp","comparitorExp","modifierExp","modifierListExp","relationExp","modifier","searchClause","boolClause","prefix","sortby","cql","fcsCql","attributeExp","regexpFlagExp","expressionTripleOperatorExp","regexpFlag","expressionTriple","fcsFcsql","BOOLEAN_OPERATORS","INDEXES","RELATION_MODIFIERS","fcsLexcql","lexcql","boolGroupInside","searchClauseInside","relationModifierInside","fieldExp","matchBraces","mapClassName","customClass","PARTNER","NAMES","BRACE_ALIAS_MAP","LEVEL_WARP","pairIdCounter","BRACE_ID_PATTERN","getPartnerBrace","brace","hoverBrace","partner","leaveBrace","clickBrace","withEventListener","toMatch","punctuation","allBraces","open","close","pairs","openStack","popped","pair","pairId","opening","closing","level","a","b","languages","plugins"],"mappings":"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"}